 
c Copyright (c) 2006 by James A. D. Connolly, Institute for Mineralogy and
c Petrography, Swiss Federal Insitute of Technology, CH-8092 Zurich,
c SWITZERLAND. All rights reserved.
 
c PSSECT - a program to generate postscript code for phase diagram sections.  
c The input data format is consistent with the files generated by VERTEX.
 
c Please do not distribute any part of this source.
 
 
      PROGRAM PSSECT
 
      implicit none

      include 'perplex_parameters.h'

      integer jop0, ier99

      logical vertex, output, first

      character*100 fname, yes*1
 
      integer  iop0 
      common / basic /iop0

      logical  debug
      common / debugblk / debug

      logical spline, half, tenth, grid, fill, label
      integer ifont, bbox 
      double precision xfac, cscale, nscale, ascale, rlabel, width      
      common/ ops /xfac,cscale,nscale,ascale,rlabel,width,bbox(4),ifont,
     *             spline,half,tenth,grid,fill,label

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p
c----------------------------------------------------------------------
c   Look for the "debug_yes" file to turn on debugging messages

      open (97,iostat=ier99,file='debug_yes',status='old')
      if (ier99.eq.0) then
          debug=.TRUE.
          close (99)
      else
          debug=.FALSE.
      end if
      close(97);

      if (debug) PRINT *,'IN PSSECT'

      iop0 = 0 
      
      vertex = .false.
      output = .false.
      first  = .false.
c                                 read input from unit n1 (terminal/disk).
c                                 subroutine input1 also initializes:
c                                 equilibrium counters; units n2 and n4;
c                                 and the limits for numerical results.
      call input1 (vertex,output,fname)

c                                 don't allow users to do anything
c                                 other than gridded min
      if (icopt.lt.5) call error (4,0d0,icopt,'PSVDRAW')
c                                 read thermodynamic data on unit n2:
      call input2 (vertex)

c                                 read autorefine lists
      call setau1 (vertex,output)
c                                 read data for solution phases on n9:
      call input9 (vertex,first,output)

      call setau2 (output)

c                                 read the plot file for grid info
      call plinp
c                                 read bulk composition data:
      call bplinp 

c                                 organize variables 
      call getvar  
c                                 initialize the grid parameters
      call setvar  
c                                 read plot option file, set
c                                 default transformation
      call rdopt 

c                                 open output file 
      call psopen (fname)    
c                                 ask for options
      write (*,1000) 
      read (*,'(a)') yes

      if (yes.eq.'y'.or.yes.eq.'Y') iop0 = 1


c                                 get user options and read
c                                 rest of plot file, draw data
      call psdplt (jop0)         
      if (debug) PRINT *,'IN PSSECT'

 
      call psclos
 
      close (n4)

1000  format ('Modify the default plot (y/n)?')

      end

      subroutine psdplt (jop0)
c----------------------------------------------------------------
c psdplt - subroutine to plot bulk compositions

      implicit none

      include 'perplex_parameters.h'

      integer lop(15), iop1, iop5, iop6, iop7, jop0

      character yes*1, prompt*14

      integer  iop0 
      common / basic /iop0

      logical  debug
      common / debugblk / debug

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      integer jbulk
      double precision cblk
      common/ cst300 /cblk(k5),jbulk

      logical oned
      common/ cst82 /oned

      logical spline, half, tenth, grid, fill, label
      integer ifont, bbox 
      double precision xfac, cscale, nscale, ascale, rlabel, width      
      common/ ops /xfac,cscale,nscale,ascale,rlabel,width,bbox(4),ifont,
     *             spline,half,tenth,grid,fill,label
c---------------------------------------------------------------
      if (debug) PRINT *,'IN PSDPLT'

      iop5 = 0
      iop6 = 0
      iop7 = 0
      lop(8) = 0 
c                                 get some options 
      call psaxop (1,jop0,iop1)
      if (iop0.eq.1) then 
c                                 restrict by assemblage
         write (*,1150) 
         read (*,1000) yes

         if (yes.eq.'y'.or.yes.eq.'Y') then
c                               if icp < jbulk write warning:
            if (icp.lt.jbulk) write (*,1400) 
            write (*,1140) 
            read (*,1000) yes
            if (yes.eq.'y'.or.yes.eq.'Y') then
               iop5 = 1
               prompt='present in the'
               call rname (1,prompt)
            end if
c                               restrict by phase presence
            write (*,1120)  
            read (*,1000) yes
            if (yes.eq.'y'.or.yes.eq.'Y') then 
               iop6 = 1
               prompt=' absent in all'
               call rname (2,prompt)
            end if 
c                               restrict by phase absence
            write (*,1130)
            read (*,1000) yes
            if (yes.eq.'y'.or.yes.eq.'Y') then 
               iop7 = 1
               prompt='present in all'
               call rname (3,prompt)
            end if 
         end if
      end if 
c                                 gridded pseudosection construction
      if (oned) then 
         call psgrd1 (jop0,iop5,iop6,iop7)
      else
         call psgrid (jop0,iop5,iop6,iop7)
      end if 

      call maktit

      call psblrb (2)
 
1000  format (a)
1120  format (/,'Show only without phases (y/n)? ')
1130  format (/,'Show only with phases (y/n)? ')
1140  format (/,'Show only with assemblage (y/n)? ')
1150  format (/,'Restrict phase fields by phase identities (y/n)?',/,
     *        '  answer yes to:',/,
     *        '   - show fields that contain a specific assemblage',/,
     *        '   - show fields that do not contain specified phases',/,
     *        '   - show fields that contain any of a set of specified',
     *            ' phases ')
1400  format (/,'WARNING: You can not specify saturated phases or',
     *          ' phases determined by',/,'component saturation',
     *          ' constraints in these restrictions.',/)       

      end 

c-----------------------------------------------------------------------
      subroutine psbtxt (id,string,iend)

c subprogram to write a text labels for bulk composition output 
c id identifies the assemblage

      implicit none

      include 'perplex_parameters.h'

      character*8 text(400)*1, string*400

      integer i, j, ist, iend, id, np, ncpd

      integer  iop0 
      common / basic /iop0

      logical  debug
      common / debugblk / debug

      integer idasls,iavar,iasct,ias
      common/ cst75  /idasls(k5,k3),iavar(3,k3),iasct,ias

      character names*8, fname*10
      common/ cst8  /names(k1)/ csta7 /fname(h9)
c----------------------------------------------------------------------
      if (debug) PRINT *,'IN PSBTXT'

      iend = 0

      string = ' '

         ist = 1
         np = iavar(1,id)
         ncpd = iavar(2,id)

         do i = 1, 400
            text(i) = ' '
         end do
c                                 first solution names:
         do i = 1, np
  
            write (string,1030) fname(idasls(i,id))
               
            ist = iend + 1
            iend = ist + 11
            read (string,1000) (text(j),j=ist,iend)
            call ftext (text,ist,iend)

         end do 
c                                   next compounds
         do i = np + 1, np + ncpd

             write (string,1030) names(-idasls(i,id)) 
             ist = iend + 1
             iend = ist + 9
             read (string,1000) (text(j),j=ist,iend)
             call ftext (text,ist,iend)

          end do               

         write (string,1000) (text(j),j=1,iend) 

1000  format (400a1)
1030  format (a)

      end 

      subroutine check1 (iop5,iop6,iop7,id,n,ntot,imatch)
c----------------------------------------------------------------------
c checkr  - subroutine to check exclusions by phase identity
c           if imatch = 0 the assemblage id matches the criteria
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer  iop0 
      common / basic /iop0

      logical  debug
      common / debugblk / debug

      integer i, n, id(n), kex(k8), ntot, imatch, iop5, iop6, iop7, 
     *        itic, itis

      integer ixct, iex, ict, jex
      common/ excl1 /ixct(3),iex(50,3),jex(50,3),ict(3)
c----------------------------------------------------------------------

      imatch = 0

      if (iop5.eq.1.or.iop6.eq.1.or.iop7.eq.1) then  

         imatch = 1

         if (iop5.eq.1) then      
 
            if (ntot.lt.ixct(1)) goto 99  
c                                 show only with assemblage:
            itic = 0

            do i = 1, ntot
c                                 if match then look at
c                                 look for the next phase
               call checki (1,id(i),kex(i))

               if (kex(i).ne.0) itic = itic + 1

            end do 
c                                 itic must = ixct if all phases match
            if (itic.lt.ixct(1))  goto 99
c                                 if here the assemblage contains
c                                 all the phases requested:
            ict(1) = ict(1) + 1

         end if

         if (iop6.eq.1) then
c                                 reject fields that contain a phase:
            do i = 1, ntot

               call checki (2,id(i),itis)
               if (itis.eq.0) cycle
c                                 name matches a phase in the field
               ict(2) = ict(2) + 1
               goto 99
 
            end do
c                                 no match
         end if

         if (iop7.eq.1) then
            do i = 1, ntot
               call checki (3,id(i),itis)
               if (itis.eq.0) cycle 
c                                 name matches a phase in the field
                ict(3) = ict(3) + 1
                goto 90

            end do
c                            no match
            goto 99

         end if

90       imatch = 0 

      end if

99    end 
 
      subroutine psgrid (jop0,iop5,iop6,iop7)
c---------------------------------------------------------------------- 
c psgrid - subprogram to output bulk composition data.

c modified to place labels at field barycenters. G Helffrich, 
c Bristol, March 24, 2006. 
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      character yes*1, text*400

      logical bad

      integer k, iran(2,k3), jran(2,k3), i, hfill, nblen,
     *        j, ipoly, idr(k5), iop5, iop6, jop0, nctr(k3),
     *        iop7, imatch, iend, ivar, ipoint, jj, ii, lex(k3), ntot,
     *        iax(l7,2), nax(2), ibeg, jbeg, jend, kk, ictr

      double precision rline, x, y, x1, y1, x2, y2, x10, cctr(2,k3), 
     *                 y10, rfill, dy, dx, bctr(2,k3), cwidth

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc

      integer igrd
      common/ cst311/igrd(l7,l7)

      integer iap,ibulk
      common/ cst74  /iap(k2),ibulk
  
      character*10 xnams
      common/ excl4 /xnams(50,3)

      integer ixct, iex, ict, jex
      common/ excl1 /ixct(3),iex(50,3),jex(50,3),ict(3)

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      double precision xmin,xmax,ymin,ymax,dcx,dcy,xlen,ylen
      common/ wsize /xmin,xmax,ymin,ymax,dcx,dcy,xlen,ylen

      logical spline, half, tenth, grid, fill, label
      integer ifont, bbox 
      double precision xfac, cscale, nscale, ascale, rlabel, width      
      common/ ops /xfac,cscale,nscale,ascale,rlabel,width,bbox(4),ifont,
     *             spline,half,tenth,grid,fill,label

      integer  iop0 
      common / basic /iop0

      logical  debug
      common / debugblk / debug

      integer jvar
      double precision var,dvr,vmn,vmx
      common/ cxt18 /var(l3),dvr(2),vmn(l3),vmx(l3),jvar

      integer idasls,iavar,iasct,ias
      common/ cst75  /idasls(k5,k3),iavar(3,k3),iasct,ias

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2
c----------------------------------------------------------------------
      if (debug) PRINT *,'IN PSGRID'

      hfill = 0 
c                                 true phase assemblage counter
      do i = 1, 3
         ict(i) = 0
      end do 

      do i = 1, k3
         lex(i) = 0
         iran(1,i) = l7
         iran(2,i) = 0 
         jran(1,i) = l7
         jran(2,i) = 0 
         nctr(i) = 0
         bctr(1,i) = 0d0
         bctr(2,i) = 0d0
      end do 

      dx = dvr(1)
      dy = dvr(2)

      rline = 2d0
      cwidth = 0

      do i = 1, loopx

         x = xmin + (i-1)*dx 

         do j = 1, loopy

            ipoly = iap(igrd(i,j))
            ntot = iavar(3,ipoly)
c
            do k = 1, ntot
               idr(k) = idasls(k,ipoly)
            end do 
c                                 check assemblage constraints
            call check1 (iop5,iop6,iop7,idr,k5,ntot,imatch)

            if (imatch.eq.1) then
c                                 this node won't be drawn 
               igrd(i,j) = 0
               lex(ipoly) = 0 
               cycle

            end if 
c                                 flag the assemblage
            lex(ipoly) = ipoly
c                                 get range of centroids
            if (j.gt.jran(2,ipoly)) jran(2,ipoly) = j 
            if (j.lt.jran(1,ipoly)) jran(1,ipoly) = j
            if (i.gt.iran(2,ipoly)) iran(2,ipoly) = i 
            if (i.lt.iran(1,ipoly)) iran(1,ipoly) = i
c                                 calculate barycenter
            nctr(ipoly) = nctr(ipoly) + 1
            bctr(1,ipoly) = bctr(1,ipoly) + i
            bctr(2,ipoly) = bctr(2,ipoly) + j
 
            rline = 0d0
            cwidth = 0d0 

            y = ymin + (j-1)*dy
c                                 ok, we're going to draw something
            call getxy (i,j,x,y,x1,y1,x2,y2)

            if (fill) then 
c                                 strip drawing
               call watend (i,j,iend)

               if (iend.eq.0) then
c                                 at middle of strip
                  cycle
               else if (iend.eq.1) then 
c                                 at bottom of strip
                  x10 = x1
                  y10 = y1
                  cycle
               else if (iend.eq.3) then
c                                 at top of strip
                  x1 = x10
                  y1 = y10
               end if 
c                                 at top of strip, draw it variance based fill
               ivar = icp + isat + 2 - ntot

               if (ivar.eq.2) then
c                                 divariant, no fill
                  call psrect (x1,x2,y1,y2,rline,cwidth,0)

               else if (ivar.le.7) then 
c                                 for di-septa-variant use gray-scale
                  rfill = 1d0- dfloat (ivar-2) * 2d-1
                  call psrecr (x1,x2,y1,y2,rline,cwidth,rfill)

               else 
c                                 variance > 7
                  if (hfill.eq.0.and.ntot.ne.0) then 
c                                 write warning, ask fill style
                     write (*,1000) 
                     read (*,'(a)') yes
c                                
                     if (yes.eq.'y'.or.yes.eq.'Y') then 
                        hfill = 2
                     else 
                        hfill = 1
                     end if 

                  end if 
c                                 use pattern fills
                  if (hfill.eq.1) call psrect (x1,x2,y1,y2,rline,
     *                                         cwidth,1+ivar)
               end if 

            end if 

         end do 

      end do 
c                                 now let's draw the edges
      do i = 1, loopx

         x = xmin + (i-1)*dx 

         do j = 1, loopy

            if (igrd(i,j).eq.0) cycle 

            y = ymin + (j-1)*dy 
c                                 ok, we're going to draw something
            call getxy (i,j,x,y,x1,y1,x2,y2)
c                                 only draw boundaries that separate
c                                 true phase assemblages.                 
            call neebor (i,j,x1,y1,x2,y2)

         end do 

      end do

      if (label) then 
c                                 last label centroids:
      do k = 1, iasct
c                                 the assemblage doesn't occur if lex(k) = 0
c                                 but this should be possible
         if (lex(k).eq.0) cycle
c                                 compute barycenter, added by 
c                                 G Helffrich, Mar 24, 2009. 
         i = max(1,nint(bctr(1,k)/nctr(k)))
         j = max(1,nint(bctr(2,k)/nctr(k)))
c                                 test that it's ok
         if (igrd(i,j).eq.0) then 
            ipoly = 0 
         else
            ipoly = iap(igrd(i,j))
         end if 

         if (ipoly.eq.lex(k)) then

            x = xmin + (i-1)*dx
            y = ymin + (j-1)*dy
            ipoint = iap(igrd(i,j))

         else 

            if (rlabel.lt.1d0) then 
c                                 ---------begin georges block-----------
            call psbtxt (lex(k), text, iend)
            call psublk (text, iend)
c                                  scan the range to find a node
c                                  with the assemblage
            nax(1) = 0
            nax(2) = 0

            ipoly = lex(k)

            do ii = iran(1,k),iran(2,k)
               do jj = jran(1,k),jran(2,k)
                  if (iap(igrd(ii,jj)).eq.ipoly) then
c                                  add i,j indices to list used
                     call iasadd(ii,nax(1),iax(1,1))
                     call iasadd(jj,nax(2),iax(1,2))
                  end if
               end do
            end do
c                                  if nothing matched, we're hosed
            if (nax(1).eq.0 .and. nax(2).eq.0) then
                write (*,*) 'uh-oh on assemblage',text(1:nblen(text))
                cycle 
            end if
c                                  determine number of contiguous ranges
c                                  of i- and j-indices.  the breaks will
c                                  mark group edges.
            ii = 1

            do i = 2,nax(1)
               if (iax(i,1)-iax(i-1,1) .gt. 1) ii = ii + 1
            end do

            jj = 1

            do i = 2,nax(2)
               if (iax(i,2)-iax(i-1,2) .gt. 1) jj = jj + 1
            end do

            if (ii*jj .gt. 1) then

               write (*,1010) max(ii,jj),text(1:nblen(text))
c                                  process dimension with largest number
c                                  of regions
               if (ii.ge.jj) then
                  j = 1
                  iend = ii
               else
                  j = 2
                  iend = jj
               end if

            else
c                                  must be a really oddly-shaped region
c                                  choose longest extent for subdivision
               ii = iax(nax(1),1) - iax(1,1)
               jj = iax(nax(2),2) - iax(1,2)

               if (ii .gt. jj) then
                  j = 1
               else
                  j = 2
               end if

               iend = 1

            end if

            ictr = 0 

            do kk=1,iend
c                                  in group kk, find limiting extent of
c                                  dimension
               jj = 1
               jbeg = iax(1,j)
               jend = iax(nax(j),j)
               do i=2,nax(j)
                  if (iax(i,j)-iax(i-1,j) .gt. 1) then
                     jj = jj + 1
                     if (jj.eq.kk) then
                        jbeg = iax(i,j)
                        cycle
                     end if
                     if (jj.gt.kk) then
                        jend = iax(i-1,j)
                        exit
                     end if
                  end if
               end do
c                                  find barycenter of elements within
c                                  extent for label.
               x = 0d0
               y = 0d0
               i = 0

               if (iend .eq. 1) then
                  ibeg = iax(1,1)
                  iend = iax(nax(1),1)
                  jbeg = iax(1,2)
                  jend = iax(nax(2),2)
                  if (j.eq.1) then
                     iend = iax(max(1,nax(1)/2),1)
                  else
                     jend = iax(max(1,nax(2)/2),2)
                  end if
               else if (j.eq.2) then
                  ibeg = iran(1,k)
                  iend = iran(2,k)
               else
                  ibeg = jbeg
                  iend = jend
                  jbeg = jran(1,k)
                  jend = jran(2,k)
               end if

               do ii=ibeg,iend
                  do jj=jbeg,jend

                     if (iap(igrd(ii,jj)).eq.ipoly) then
                        i = i + 1
                        x = x + dfloat(ii)
                        y = y + dfloat(jj)
                     end if

                  end do
               end do

               ii = max(1,nint(x/i))
               jj = max(1,nint(y/i))
c                                  in the money this time -- agrees?
               ipoint = iap(igrd(ii,jj))

               if (ipoint.ne.lex(k)) then 
                  write (*,*) '**oops - barycenter at ',x,y,
     *              ' for ',text(1:nblen(text)),' region ',kk,' missed'
               else 
                  ictr = ictr + 1
                  cctr(1,ictr)  = xmin + dfloat(ii-1)*dx
                  cctr(2,ictr)  = ymin + dfloat(jj-1)*dy
                  if (ictr.gt.k3) exit
               end if 

            end do
c                                  now check that the barycenters are 
c                                  far enough apart:
            do ii = 1, ictr
         
               x = cctr(1,ii)
               y = cctr(2,ii)
               bad = .false.

               do jj = ii+1, ictr

                  if ( dsqrt( ((x-cctr(1,jj))/xlen)**2 
     *                       +((y-cctr(2,jj))/ylen)**2).lt.rlabel) then

                     bad = .true.
                     exit
                  end if 
               end do 

               if (bad) cycle

               call pselip (x,y, 0.25d0*dcx, 0.25d0*dcy, 1d0,0d0,0)
               call pssctr (ifont,ascale,ascale, 0d0)
               call pstext (x+dcx*ascale,y+.7d0*dcy*ascale,
     *                      text,nblen(text),mdAlgn,ltAlgn)

            end do 

            cycle
c                                 ---------end george's block------------
            end if 

            ipoly = lex(k)
c                                 scan the range to find a node 
c                                 with the assemblage
            if (jran(2,k).gt.2) then
c                                 first try to find one at an i-value 
c                                 at half the j-range
               jj = jran(2,k)/2
               do ii = iran(1,k), iran(2,k)

                  if (igrd(ii,jj).eq.0) cycle

                  if (iap(igrd(ii,jj)).eq.ipoly) then
                     ipoint = iap(igrd(ii,jj))
                     x = xmin + (ii-1)*dx
                     y = ymin + (jj-1)*dy
                     goto 50
                  end if 
               end do 
            end if 

            if (iran(2,k).gt.2) then 
c                                 next try to find one at an j-value 
c                                 at half the i-range
               ii = iran(2,k)/2
               do jj = jran(1,k), jran(2,k)

                  if (igrd(ii,jj).eq.0) cycle

                  if (iap(igrd(ii,jj)).eq.ipoly) then
                     ipoint = iap(igrd(ii,jj))
                     x = xmin + (ii-1)*dx
                     y = ymin + (jj-1)*dy
                     goto 50
                  end if 
               end do 
            end if 
c                                 last try, scan the range to find a node 
c                                 with the assemblage
            do ii = iran(1,k), iran(2,k)
               do jj = jran(1,k), jran(2,k)

                  if (igrd(ii,jj).eq.0) cycle

                  if (iap(igrd(ii,jj)).eq.ipoly) then
                     ipoint = iap(igrd(ii,jj))
                     x = xmin + (ii-1)*dx
                     y = ymin + (jj-1)*dy
                     goto 50
                  end if 
               end do 
            end do 
c                                 no grid point found for the 
c                                 assemblage, perhaps the resetting of
c                                 igrd to zero allows this?
            write (*,*) 'uh-oh on assemblage', ipoly
            cycle

         end if 
c                                 call label routine:
50       call pselip (x,y, 0.25d0*dcx, 0.25d0*dcy,1d0,0d0,0) 
         call psbtxt (ipoint, text, iend)
         call pssctr (ifont,ascale,ascale, 0d0)
         call pstext (x+dcx*ascale,y+.7d0*dcy*ascale,text, 
     *                iend,mdAlgn,ltAlgn)

      end do 

      end if 
c                                 draw axes
      call psaxes (jop0)
 
      if (iop5.eq.1) write (*,*) ict(1),
     *               ' fields have the assemblage: ',
     *               (xnams(k,1),' ',k = 1, ixct(1))

      if (iop6.eq.1) write (*,*) ict(2),
     *               ' fields do not have any of the phases: ',
     *               (xnams(k,2),' ',k = 1, ixct(2))

      if (iop7.eq.1) write (*,*) ict(3),
     *               ' fields do have one of the phases: ',
     *               (xnams(k,3),' ',k = 1, ixct(3))

1000  format (/,'**warning ver099** the section contains phase fields',
     *          ' of variance > 6',/,'these will be drawn with pattern',
     *          ' fills that may look strange.',/,'Suppress phase ',
     *          'field fills for fields with variance > 6 (y/n)? ')
1010  format ('There are ',i3,' fields for: ',a)

      end

      integer function nblen(str)
c--------------------------------------------------------------- 
c george's function for psgrid, 
c replicates a function already in perple_x
c nblen - function to return nonblank length of a string
      character str*(*)
      integer i

      do i=len(str),1,-1
         if (str(i:i) .ne. ' ') exit
      end do
      nblen = i
      end

      subroutine iasadd(m,n,tab)
c----------------------------------------------------------------------
c george's function for psgrid
c iasadd - routine to add m to an ordered table of n elements in tab.
      implicit none

      integer  iop0 
      common / basic /iop0

      logical  debug
      common / debugblk / debug

      integer i,j,jlo,jhi,k,m,n,tab(*)

      if (n.le.0) then
c                                  nothing in table is a special case
         tab(1) = m
         n = 1
         return
      end if

      if (n .eq. 1) then
c                                  one item in table is too
         if (m .eq. tab(1)) return
         if (m .gt. tab(1)) then
            tab(2) = m
         else
            tab(2) = tab(1)
            tab(1) = m
         end if

      else
c                                  do binary search for insertion point
         j = n/2
         jlo = 1
         jhi = n

         do
c                                  quit if in table already
            if (m .eq. tab(j)) return
            if (m .gt. tab(j)) then
c                                  lower half
               jlo = j+1
            else
c                                  upper half
             jhi = j-1
            end if
c                                  next check point -- insert if absent
            k = (jlo+jhi)/2
            if (j .eq. k .or. k .eq. 0) then
c                                  move entries in table down, insert new
             do i=n,k+1,-1
                tab(i+1) = tab(i)
             end do
             tab(k+1) = m
             exit
          end if
          j = k
         end do
      end if
c                                  one more added
      n = n + 1

      end

      subroutine psgrd1 (jop0,iop5,iop6,iop7)
c----------------------------------------------------------------------
c psgrd1 - subprogram draw 1d gridded minimization diagrams.

      implicit none

      include 'perplex_parameters.h'

      character yes*1, text*400

      integer k, hfill, jop0,
     *        j, ipoly, idr(k5), iop5, iop6, jmin, jmax,
     *        iop7, imatch, iend, ivar, jj, ntot

      double precision rline, x, y, x1, y1, x2, y2, xl,
     *                 x10, rfill, dx

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc

      integer igrd
      common/ cst311/igrd(l7,l7)

      integer iap,ibulk
      common/ cst74  /iap(k2),ibulk

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      double precision xmin,xmax,ymin,ymax,dcx,dcy,xlen,ylen
      common/ wsize /xmin,xmax,ymin,ymax,dcx,dcy,xlen,ylen

      logical spline, half, tenth, grid, fill, label
      integer ifont, bbox 
      double precision xfac, cscale, nscale, ascale, rlabel, width      
      common/ ops /xfac,cscale,nscale,ascale,rlabel,width,bbox(4),ifont,
     *             spline,half,tenth,grid,fill,label

      integer jvar
      double precision var,dvr,vmn,vmx
      common/ cxt18 /var(l3),dvr(2),vmn(l3),vmx(l3),jvar

      integer  iop0 
      common / basic /iop0

      logical  debug
      common / debugblk / debug

      integer idasls,iavar,iasct,ias
      common/ cst75  /idasls(k5,k3),iavar(3,k3),iasct,ias

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2
c----------------------------------------------------------------------
      if (debug) PRINT *,'IN PSGRD1'

      hfill = 0 
c                                default fill mode by variance:   
      y1   = ymin
c  DMH default to 6% of total y-axis "size" (1.0)
      y2   = ymin + 0.06
      y    = (y1+y2)/2d0     
      dx   = dvr(1)
      x    = xmin - dx
      jmin = loopy
      jmax = 0 

      do j = 1, loopy

         x = x + dx 

         ipoly = iap(igrd(1,j))
         ntot = iavar(3,ipoly)
c
         do k = 1, ntot
            idr(k) = idasls(k,ipoly)
         end do 
c                                 check assemblage constraints
         call check1 (iop5,iop6,iop7,idr,k5,ntot,imatch)
c                                 get range of centroids
         if (j.gt.jmax) jmax = j 
         if (j.lt.jmin) jmin = j
 
         rline = 0d0

         call gety (j,x,x1,x2)

         if (fill) then 
c                                 strip drawing
            call watend (1,j,iend)

            if (iend.eq.0) then
c                                 at middle of strip
               cycle 
            else if (iend.eq.1) then 
c                                 at bottom of strip
               x10 = x1
               cycle  
            else if (iend.eq.3) then
c                                 at top of strip
               x1 = x10
            end if 
c                                 going to draw something
c                                 variance based fill
            ivar = icp + isat - ntot

            if (ivar.eq.0) then
c                                 white (no fill)
c DMH: removed dashes
c               call psrect (x1,x2,y1,y2,2d0,0d0,0)
               call psrect (x1,x2,y1,y2,0d0,0d0,0)

            else if (ivar.le.6) then 
c                                 for di-septa-variant use gray-scale
               rfill = 1d0 - dfloat (ivar) * 0.2d0
c DMH               call psrecr (x1,x2,y1,y2,2d0,0d0,rfill)
               call psrecr (x1,x2,y1,y2,0d0,0d0,rfill)

            else 

               if (hfill.eq.0.and.ntot.gt.0) then 
c                                 write warning
                     write (*,1000) 
                     read (*,'(a)') yes
c                                 suppress > hexavariant fills
                     if (yes.eq.'y'.or.yes.eq.'Y') then 
                        hfill = 2
                     else 
                        hfill = 1
                     end if 
               end if 
c                                 use pattern fills
c DMH removed dashes:
c               if (hfill.eq.1) call psrect (x1,x2,y1,y2,2d0,
c     *                                         0d0,1+ivar)
               if (hfill.eq.1) call psrect (x1,x2,y1,y2,0d0,
     *                                         0d0,1+ivar)
            end if 

         end if 

         if (label) then
c                                 place a label on the field
            jj = (jmin+jmax)/2
            xl = xmin + (jj-1)*dx

            call pselip (xl,y,0.25d0*dcx,0.25d0*dcy,1d0,1d0,0) 
            call psbtxt (ipoly, text, iend)
            call pssctr (ifont, ascale, ascale, 90d0)
            call pstext (xl-0.7*dcx*ascale,y2,
     *                   text,iend,mdAlgn,ltAlgn+500)
c DMH Remove rotation:     
            call pssctr (ifont, ascale, ascale, 0d0)

            jmin = loopy
            jmax = 0 

         end if 

      end do 
c                                  now let's draw the edges
      x = xmin

      do j = 1, loopy

         if (igrd(1,j).eq.0) cycle 
c                                  ok, we're going to draw something
         call gety (j,x,x1,x2)
c                                  only draw boundaries that separate
c                                  true phase assemblages.                 
         call nebor1 (j,x1,y1,x2,y2)

         x = x + dx  

      end do 

      call psax1d (jop0)

1000  format (/,'**warning ver099** the section contains phase fields',
     *          ' of variance > 6',/,'these will be drawn with pattern',
     *          ' fills that may look strange.',/,'Suppress phase ',
     *          'field filling for fields with variance > 6 (y/n)? ')
      end

c----------------------------------------------------------------------
      subroutine psax1d (jop0)
 
c psax1d - subroutine to output (sloppy) 1d axes.

      implicit none

      double precision x0,dx,ytic,ytic1,ytic2,y,x

      integer jop0,i,j

      include 'perplex_parameters.h'
 
      character record*20, yes*1

      integer jvar
      double precision var,dvr,vmn,vmx
      common/ cxt18 /var(l3),dvr(2),vmn(l3),vmx(l3),jvar

      character vnm*8
      common/ cxt18a /vnm(l3)   

      double precision xmin,xmax,ymin,ymax,dcx,dcy,xlen,ylen
      common/ wsize /xmin,xmax,ymin,ymax,dcx,dcy,xlen,ylen

      integer  iop0 
      common / basic /iop0

      logical  debug
      common / debugblk / debug

      logical spline, half, tenth, grid, fill, label
      integer ifont, bbox 
      double precision xfac, cscale, nscale, ascale, rlabel, width      
      common/ ops /xfac,cscale,nscale,ascale,rlabel,width,bbox(4),ifont,
     *             spline,half,tenth,grid,fill,label

      integer iind, idep
      double precision c0,c1,c2,c3,c4,c5
      common/ cst316 /c0,c1,c2,c3,c4,c5,iind,idep
c---------------------------------------------------------------------- 
      if (debug) PRINT *,'IN PSAX1D'

      x0 = xmin

      dx = xlen / 5d0
 
      ytic  = 0.01d0
      ytic1 = ytic*.67d0
      ytic2 = ytic1*.67d0 

      if (jop0.eq.1) then

         write (*,1010) 
         read (*,1020) yes
         if (yes.ne.'y'.and.yes.ne.'Y') goto 10

         write (*,1030) 'X', x0, dx
         read (*,*) x0, dx

      end if 
c                                 draw axes box
      if (debug) PRINT *,'READY for PSRECT in PSAX1D'
c10    continue
10    call psrect (xmin,xmax,ymin,ymin+0.06,1d0,width,0)
c                                 draw bottom horizontal axis
      call psxtic (ymin, x0, dx, ytic, ytic1, ytic2)
 
      call pssctr (ifont, nscale, nscale, 0d0)
c                                  numeric axis labels:
      call psxlbl (x0, dx)
c                                  x-axis name
      call pssctr (ifont, nscale, nscale, 0d0)

      x = xmin + 0.5d0 * xlen - 2d0*dcx*nscale
      y = ymin - 6d0*dcy*nscale

      call pstext (x,y,vnm(1),0,tpAlgn+200,ctAlgn)
c                                  sectioning constraints
      if (jvar.gt.1) then
 
         j = jvar 
         if (idep.ne.0) j = j - 1

         call pssctr (ifont,nscale,nscale,0d0)
         do i = 2, j 
            write (record,1000) vnm(i),vmn(i)
            call pstext (xmin,ymax,record,0,btAlgn+(i-2)*1000,ltAlgn)
         end do 
 
      end if
 
1000  format (a,'=',g9.3)
1010  format (/,'Modify default axes (y/n)?')
1020  format (a)
1030  format (/,'Enter the starting value and interval for',
     *          ' major tick marks on',/,'the ',a,'-axis (',
     *          'current values are:',2(1x,g9.3),')',/, 
     *          'Enter the new values:')

      end

c---------------------------------------------------------------------- 
      subroutine gety (j,y,y1,y2)

c gety - get coordinates for 1d grid node volume

      implicit none

      include 'perplex_parameters.h'

      integer j

      double precision y,y1,y2,dy

      integer jvar
      double precision var,dvr,vmn,vmx
      common/ cxt18 /var(l3),dvr(2),vmn(l3),vmx(l3),jvar

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc
c----------------------------------------------------------------------

      dy = dvr(1)

      if (j.gt.1.and.j.lt.loopy) then

         y1 = y - 0.5d0*dy
         y2 = y + 0.5d0*dy

      else if (j.eq.loopy) then 

         y2 = y
         y1 = y - 0.5d0*dy

      else if (j.eq.1) then 

         y1 = y
         y2 = y + 0.5d0*dy

      else 

         y1 = y - 0.5d0*dy
         y2 = y + 0.5d0*dy

      end if 

      end 

c---------------------------------------------------------------------- 
      subroutine getxy (i,j,x,y,x1,y1,x2,y2)

c getxy - get coordinates for grid node volume

      implicit none

      include 'perplex_parameters.h'

      integer i,j

      double precision x,y,x1,x2,y1,y2,dx,dy

      integer jvar
      double precision var,dvr,vmn,vmx
      common/ cxt18 /var(l3),dvr(2),vmn(l3),vmx(l3),jvar

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc
c----------------------------------------------------------------------

      dx = dvr(1)
      dy = dvr(2)

      if (i.gt.1.and.i.lt.loopx.and.j.gt.1.and.j.lt.loopy) then

         x1 = x - 0.5d0*dx
         x2 = x + 0.5d0*dx
         y1 = y - 0.5d0*dy
         y2 = y + 0.5d0*dy
         goto 99

      end if 
c                                 on an edge:
      if (j.eq.loopy) then 
         y2 = y
         y1 = y - 0.5d0*dy
      else if (j.eq.1) then 
         y1 = y
         y2 = y + 0.5d0*dy
      else 
         y1 = y - 0.5d0*dy
         y2 = y + 0.5d0*dy
      end if 

      if (loopx.eq.1) then 
         x1 = x
         x2 = x + 0.5d0*dx
      else if (i.eq.loopx) then 
         x1 = x - dx*0.5d0
         x2 = x
      else if (i.eq.1) then 
         x1 = x
         x2 = x + 0.5d0*dx
      else 
         x1 = x - 0.5d0*dx
         x2 = x + 0.5d0*dx
      end if 

99    end 

c----------------------------------------------------------------------
      subroutine neebor (i,j,x1,y1,x2,y2)

c neebor - check, which, if any adjacent grid points have
c a different phase assmblage.

      implicit none

      include 'perplex_parameters.h'

      double precision rline,x1,y1,x2,y2
 
      integer i,j,id,im1,jm1,ip1,jp1

      integer iap,ibulk
      common/ cst74  /iap(k2),ibulk

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc

      integer igrd
      common/ cst311/igrd(l7,l7)

      logical spline, half, tenth, grid, fill, label
      integer ifont, bbox 
      double precision xfac, cscale, nscale, ascale, rlabel, width      
      common/ ops /xfac,cscale,nscale,ascale,rlabel,width,bbox(4),ifont,
     *             spline,half,tenth,grid,fill,label
c----------------------------------------------------------------------

      rline = 1d0

      id = iap(igrd(i,j))

      if (i.eq.1) then
         im1 = id
      else if (igrd(i-1,j).eq.0) then 
         im1 = 0
      else
         im1 = iap(igrd(i-1,j))
      end if

      if (i.eq.loopx) then 
         ip1 = id
      else if (igrd(i+1,j).eq.0) then 
         ip1 = 0
      else
         ip1 = iap(igrd(i+1,j))
      end if  

      if (j.eq.1) then 
         jm1 = id
      else if (igrd(i,j-1).eq.0) then 
         jm1 = 0
      else
         jm1 = iap(igrd(i,j-1))
      end if 

      if (j.eq.loopy) then 
         jp1 = id
      else if (igrd(i,j+1).eq.0) then 
         jp1 = 0
      else
         jp1 = iap(igrd(i,j+1))
      end if 
                          
      if (i.ne.1.and.im1.ne.id) 
     *    call psline (x1,y1,x1,y2,rline,width)
      if (j.ne.loopy.and.jp1.ne.id)
     *    call psline (x1,y2,x2,y2,rline,width)
      if (i.ne.loopx.and.ip1.ne.id) 
     *    call psline (x2,y1,x2,y2,rline,width)
      if (j.ne.1.and.jm1.ne.id) 
     *    call psline (x1,y1,x2,y1,rline,width)

      end 

c----------------------------------------------------------------------
      subroutine nebor1 (j,x1,y1,x2,y2)

c neebor - check, which, if any adjacent grid points have
c a different phase assmblage.

      implicit none

      include 'perplex_parameters.h'

      double precision rline,x1,y1,x2,y2
 
      integer j,id,jm1,jp1

      integer iap,ibulk
      common/ cst74  /iap(k2),ibulk

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc

      integer igrd
      common/ cst311/igrd(l7,l7)

      logical spline, half, tenth, grid, fill, label
      integer ifont, bbox 
      double precision xfac, cscale, nscale, ascale, rlabel, width      
      common/ ops /xfac,cscale,nscale,ascale,rlabel,width,bbox(4),ifont,
     *             spline,half,tenth,grid,fill,label
c----------------------------------------------------------------------

      rline = 1d0

      id = iap(igrd(1,j))

      if (j.eq.1) then 
         jm1 = id
      else if (igrd(1,j-1).eq.0) then 
         jm1 = 0
      else
         jm1 = iap(igrd(1,j-1))
      end if 

      if (j.eq.loopy) then 
         jp1 = id
      else if (igrd(1,j+1).eq.0) then 
         jp1 = 0
      else
         jp1 = iap(igrd(1,j+1))
      end if 
                          
      if (j.ne.loopy.and.jp1.ne.id)
     *    call psline (x2,y1,x2,y2,rline,width)

      if (j.ne.1.and.jm1.ne.id) 
     *    call psline (x1,y1,x1,y2,rline,width)

      end 


c--------------------------------------------------------------- 
      subroutine watend (i,j,iend)

c watend - check, which, if any adjacent grid points have
c a different phase assmblage.

c    iend = 0, no edges are ends
c    iend = 1, bottom edge is an end
c    iend = 2, both edges are ends
c    iend = 3, top edge is an end

      implicit none

      include 'perplex_parameters.h'
 
      integer i,j,id,ijm1,ijp1,iend

      integer iap,ibulk
      common/ cst74  /iap(k2),ibulk

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc

      integer igrd
      common/ cst311/igrd(l7,l7)
c----------------------------------------------------------------------

      id = iap(igrd(i,j))

      if (j.eq.loopy) then
         ijp1 = iap(igrd(i,j))
      else if (igrd(i,j+1).ne.0) then 
         ijp1 = iap(igrd(i,j+1))
      else 
         ijp1 = 0
      end if 

      if (j.eq.1) then 
         ijm1 = iap(igrd(i,j))
      else if (igrd(i,j-1).ne.0) then 
         ijm1 = iap(igrd(i,j-1))
      else 
         ijm1 = 0
      end if 

      if (j.eq.1) then 
         iend = 1
         if (id.ne.ijp1) then 
            iend = 2
         end if 
      else if (j.eq.loopy) then
         iend = 3
         if (id.ne.ijm1) then 
            iend = 2
         end if 
      else if (id.ne.ijp1.and.id.ne.ijm1) then 
         iend = 2
      else if (id.ne.ijm1) then 
         iend = 1
      else if (id.ne.ijp1) then 
         iend = 3
      else 
         iend = 0
      end if 
                          
      end 

c----------------------------------------------------------------------
      subroutine rname (iw,prompt)

      implicit none

      character*10 xnam, prompt*14

      integer iw, iam 

      integer ixct, iex, ict, jex
      common/ excl1 /ixct(3),iex(50,3),jex(50,3),ict(3)

      character*10 xnams
      common/ excl4 /xnams(50,3)
c----------------------------------------------------------------------
      ixct(iw) = 0

      do 

         write (*,1040) prompt
         read (*,1020) xnam
   
         if (xnam.eq.' ') exit

         call matchj (xnam,iam)

         if (iam.eq.0) then
            write (*,1100) xnam
            cycle
         end if

         ixct(iw) = ixct(iw) + 1
         iex(ixct(iw),iw) = iam
         xnams(ixct(iw),iw) = xnam
 
      end do 

1020  format (a)
1040  format (/,'Enter the name of a phase ',a,' fields',
     *        /,'(left justified, <cr> to finish): ')
1100  format (/,'No such entity as ',a,', try again: ')

      end 


      subroutine checki (iw,iun,itis)
c----------------------------------------------------------------------
c checki - subroutine to determine if the phase iun is in the
c          list exclude list, two versions one in psect checks
c          only one index list, the other on psvdraw checks two
c          lists.

c   itis = 0 if not, itis>=0 if it is.
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i, iw, iun, itis
 
      integer ixct, iex, ict, jex
      common/ excl1 /ixct(3),iex(50,3),jex(50,3),ict(3)

      itis = 0 

      do i = 1, ixct(iw)
         if (iun.eq.iex(i,iw)) then
            itis = iun
            exit
         end if
      end do 
 
      end
